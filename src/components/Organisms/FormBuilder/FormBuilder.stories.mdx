import { Meta } from '@storybook/addon-docs';

<Meta title="COMPONENTS/Organisms/FormBuilder/Docs" />

### شماره تسک در جیرا:

### توضیحات:

این کامپوننت فرم بیلدر است. به طور خلاصه یک schema میگیرد، اینپوت ها و المنت ها را میچیند و در نهایت فرم را میسازد و درون تگ form  رندر میکند. در ورودی، schema میگیرد و در خروجی، متد هایی مانند onSubmit و onFormChange را صدا میکند. این کامپوننت برای فرم از react-hook-form استفاده میکند. اینپوت هارا از طریق کامپوننت Controller که در react-hook-form میباشد رندر میکند.


### props ها و قابلیت ها:

- **schema** اسکیما ی فیلد ها را مشخص میکند. آرایه است.
- **formOptions** آپشن های react-hook-form که مستقیم به useForm پاس داده میشود.
- **onFormChange** اگر اراعه شود، با هر تغییر فرم، صدا زده میشود. در آن در پارامتر اول مقادیر فرم و در پارامتر دوم پراپس های کل فرم پاس داده میشود.
- **onSubmit** اگر فرم سابمیت شود این کالبک صدا زده میشود. در آن در پارامتر اول مقادیر فرم و در پارامتر دوم پراپس های کل فرم پاس داده میشود.
- **defaultRequiredErrorMessage** پیغام ارور پیشفرض را مشخص میکند. اگر در اسکیما در قسمت props پراپرتی required باشد و rule در اسکیما نداده شده باشد، به طور اتوماتیک فرم بیلدر این فیلد را اجباری میکند و چون پیغام ارور ندارد، از این مقدار پیشفرض استفاده میکند. با این تفاوت که در پیغام پیشفرض، دنبال کاراکتر $ میگردد و آن را با props?.label جایگزین میکند. در نتیجه نام فیلد را + پیغام پیشفرض ترکیب میکند و در پیغام اجباری بودن فیلد نمایش میدهد. به طور پیشفرض این پیغام به این شکل است که میتوان آن را تغییر داد:
- $ الزامی می‌باشد
- **formDefaultValues** مقادیر پیشفرض فرم را تعیین میکند. اگر فرم  edit باشد این مقادیر در فیلد های مربوطه مینشینند.
- **توجه**: برای اینکه دست باز باشد این پراپ اگر تغییر کند فرم نیز مجدد مقادیر را در فیلد ها میچیند. پس میتواند مجدد تغییر کند و فرم ری-رندر شود.
- **className** استرینگ کلاس های فرم است که مستقیما به تگ form پاس داده میشود.
- **formMethod** متد فرم را مشخص میکند که آیا این فرم برای افزودن جدید است، برای ادیت است، یا صرفا برای نمایش است. سه مقدار زیر را میگیرد:
  - new
  - update
  - view


### نحوه استفاده از FormBuilder:

جهت استفاده از فرم بیلد میبایست کامپوننت ` <FormBuilder />` را رندر کرده و به آن پراپ های اجباری form و schema را پاس دهید.

formBuilder میبایست از  `useFormBuilder()` استفاده کند.

```tsx

  const formBuilder = useFormBuilder();


  <FormBuilder
      form={formBuilder}
      onSubmit={(formValues: any) => console.log(formValues)}
      schema={[
      {
        fieldType: "Input",
        width: "1/2",
        rule: yup.string().required("موبایل الزامی میباشد").length(11, "موبایل باید 11 رقم باشد"),
        props: {
          name: "mobileNum",
          label: "شماره موبایل",
          placeholder: "شماره موبایل",
          type: "number",
          required: true,
          preserveErrorBox: true
        }
      },
      ]}
  />
```

### useFormBuilder

useFormBuilder یک هوک است که مقادیر useForm را برمیگرداند. از طریق این مقادیر میتوان به پراپرتی هایی مانند موارد زیر دسترسی داشت:

- clearErrors
- formState
- getFieldState
- getValues
- register
- reset
- watch
- ... و باقی مواردی که از useForm ریترن میشوند.

```tsx
  const formBuilder = useFormBuilder();
  const { clearErrors, formState, getFieldState, getValues, register, reset, watch } = formBuilder.formProps;
  
  const isFormSubmitting = formState.isSubmitting;
  const allFieldsValues = watch();

```

### ساختار آبجکت های schema
```text
  {
      "fieldType": String,
      "className": String,
      "width": String, // "1/2" | "1/3" | "1/4"
      "rule": yup,
      "value": string | (formData) => void
      "props": Object | (formProps) => object,
      "hideOnForm": ({ formProps, formMethod }) => Boolean,
      "component": (formProps) => any
  }
```


### یک نمونه schema
```json
  [
    {
        "type": "Input",
        "width": "1/2",
        "rule": "yup.string().required('موبایل الزامی میباشد').length(11, 'موبایل باید 11 رقم باشد')",
        "props": {
          "name": "mobileNumber",
          "label": "شماره موبایل",
          "placeholder": "شماره موبایل",
          "type": "number",
          "required": true,
          "preserveErrorBox": true
        }
     }
  ]
```
- **fieldType** تایپ، تعیین کننده ی کامپوننتی است که باید نمایش داده شود. میتواند دو حالت مختلف را بگیرد
- یا اسم کامپوننت است. مثلا Input یا Button یا InputBankCard یا ... هر کامپوننتی که در پوشه ی src روت پروژه موجود است. باید اسم آن دقیقا اسم کامپوننت باشد. مثلا InputBankCard اگر به اشتباه inputbankcard تایپ شود کامپوننت پیدا نخواهد شد.
- یا اسم آن space است جهت نمایش یک کامپوننت خالی جهت چیدمات بهتر فرم.
- **width** عرض فیلد را تعیین میکند. گاهی نیاز است دوتا فیلد در کنار هم قرار گیرند. با این پراپرتی میتوان این کار را انجام داد. مقادیر زیر را میگیرد:
- "1/2" | "1/3" | "1/4" | null
- **rule** جهت ولیدیشن استفاده میشود. با آن میتوان ولیدیشن این فیلد را مشخص کرد. نوع آن از نوع کتابخانه ی yup است. مثال:
- yup.string().required
- **props** پراپ های خود کامپوننت است که مستقیم به آن پاس داده میشود. ولی توجه کنید از این پراپ ها، فرم بیلدر پراپ های name, label, required را میخواند. از name برای اسم فیلد استفاده میکند و با استفاده از آن مقدار آن را درون formDefaultValues پیدا کرده و به آن بایند میکند. همچنین از label استفاده کرده و در defaultRequiredErrorMessage همانطور که در بالاتر قبلا توضیح داده شد، استفاده میکند. همچنین اگر rule اراعه نشده باشد، میآید required را چک میکند و مثبت بود این فیلد را اجباری تلقی میکند.
- **value** اگر اراعه شده باشد، مستقیم مقدار فیلد را برابر این مقدار قرار میدهد و از گشتن در formDefaultValues صرف نظر میکند. این پراپرتی میتواند استرینگ یا فانکشن باشد. اگر فانکشن باشد به آن formProps داده میشود.
- **hideOnForm** فانکشنی است که اگر اراعه شده باشد و صدا زده شود، اگر مقدار true برگرداند این فیلد را مخفی میکند و اگر false برگرداند مجدد آن را نمایش میدهد. به این فانکشن  formProps و  formMethod به عنوان ورودی داده میشود.
- **component** کامپوننت کاستوم. فانکشن باید باشد. به آن formProps به عنوان ورودی داده میشود.
- **className** کلاسی کاستومی که در div در wrapper فیلد داده میشود.


### نحوه عملکرد schema و شیوه رندر شد فیلد ها:
جهت نمایش فیلد ها، سه حالت مختلف چک میشود:

  - اگر در اسکیما، فانکشن component اراعه شده باشد، این فیلد، یک فیلد کاستوم تلقی میشود و آن فانکشن صدا زده شده و هرچه بازگرداند نمایش داده میشود.
  - اگر در اسکیما، تایپ برابر با space تعیین شده باشد یک کامپوننت خالی نمایش داده میشود. (گاهی برای چیدمان فرم مورد استفاده قرار میگیرد)
  - اگر این دوحالت نبود، به دنبال کامپوننت میگردد و آن را اگر پیدا کرد، نمایش میدهد. اگر هیچ کامپوننتی پیدا نشد، هیچ چیز برنمیگرداند!
- نوع کامپوننت در اسکیما، در پراپرتی fieldType تعیین شده. کاراکتر اول اسم کامپوننت را اتوماتیک بزرگ میکند. مثلا input → Input.
- جهت نمایش کامپوننت همیشه آن را درون یک wrapper که از نوع <"\div\"> است قرار میدهد (جهت چیدمان فرم و فلکس)

هنگامی که دارد دنبال کامپوننت میگردد، به طور کلی دوحالت در نظر گرفته شده است:
- ابتدا در درون فولدر ../FieldsWrappers به دنبال اسم wrapper کاستوم کامپوننت میگردد. اگر کامپوننت یک wrapper خاص داشت و فرم بلیدر توانست آن را پیدا کند، آن را صدا میزند.
- نحوه گشتن آن به این صورت است که در انتهای اسم کامپوننت، کلمه ی Wrapper را قرار میدهد. اگر چنین کامپوننتی بود یعنی پیدا شده است. مثال: اگر fieldType برابر NumberInput باشد به دنبال NumberInputWrapper خواهد گشت!
- اگر wrapper آن کامپوننت را پیدا نکرد، از GeneralWrapper استفاده میکند و کامپوننت پیدا شده را در غالب پراپرتی component به GeneralWrapper پاس میدهد. در این حالت به دنبال تمام کامپوننت ها در درون فولدر اصلی "src" میگردد تا آن کامپوننت را پیدا کند. مثلا اگر fieldType برابر Badge باشد کامپوننت badge را میآورد. اگر باز هم کامپوننت را پیدا نکرد کلا این فیلد نال خواهد بود و چیزی رندر نمیشود.

### ساختار GeneralWrapper:
```text
  <Controller
       name={propsInFieldSchema.name}
       control={formProps.control}
       render={({ field, fieldState }) => (
         <Component {...{ ...field, error: fieldState.error?.message, ...propsInFieldSchema }} />
       )}
  />
```

### پراپرتی های پاس داده شده به Wrapper ها :
```text
  {
      "fieldSchema", // اسکیما ی فیلد
      "formProps", // پراپرتی های فرم اصلی
      "propsInFieldSchema", // پراپ های فیلد که در اسکیما بود
      "component" // کامپوننتی که باید رندر شود. این پراپرتی فقط به جنرال رپر داده میشود و اگر رپر کاستوم باشد نیازی به این پراپرتی نیست و داده نخواهد شد.
  }
```
### نحوه سابمیت فرم از خارج از فرم :

 جهت سابمیت کردن فرم از خارج از فرم ابتدا به فرم id داده و در button  که وظیفه ی سابمیت را دارد id در attribute به اسم form اضافه کنید:
 
 اطلاعات بیشتر: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#attr-form

```html
      <FormBuilder id="form-1" {...args} > </FormBuilder>

      <button type="submit" form="form-1">
        Submit button (outside of the form)
      </button>

```

### نحوه سابمیت فرم در درون schema :
جهت سابمیت فرم میتوانید از یک کامپوننت باتن استفاده کرده و نوع آن را submit قرار دهید:
```json
  {
    "fieldType": "Button",
    "props": {
      "type": "submit",
      "children": "ثبت نام"
    },
    "width": "1/2"
  }
```



### یک نمونه از نمایش یک فیلد بر اساس فیلد دیگر :
همانطور که بالاتر توضیح داده شد باید از hideOnForm استفاده شود. در این مثال ما میخواهیم فقط زمانی فیلد کد پستی را نشان دهد که حتما فیلد آدرس پر شده باشد. به این منظور آن را اینطور مینویسیم:

```json
  {
    "fieldType": "Input",
    "width": "1/2",
    "hideOnForm": "({ formProps, formMethod }) => (!formProps.watch('address') ? true : false)",
    "props": {
      "name": "postalCode",
      "label": "کد پستی",
      "placeholder": "کد پستی",
      "type": "number",
      "required": true,
      "preserveErrorBox": true
    }
  }

```


### یک نمونه از ولیدیشن یک فیلد بر اساس فیلد دیگر :
همانطور که بالاتر توضیح داده شد میتوانیم از طریق yup این امر را میسر نماییم. به طور مثال میخواهیم فقط زمانی شماره تلفن اجباری شود که آدرس پر شده باشد. در غیر اینطورت نمیخواهیم تلفن اجباری باشد. همچنین برای تست دسترسی به مقدار یک فیلد دیگر، ما در این مثال علاوه بر پربودن آدرس، مقدار آن را نیز چک کردیم و گفتیم اگر در آدرس کلمه ی تهران وجود داشت، علاوه بر اجباری بودن، میبایست ۸ رقمی نیز شود. به این منظور میتوانیم بنویسیم:

```js
  {
    fieldType: "Input",
    width: "1/2",
    rule: yup.string().when("address", {
        "is": val => val?.length > 0,
        "then": yup.string().required("در صورتی که آدرس پر شده باشد تلفن اجباری می‌شود")
      })
      .when("address", {
        is: val => val?.includes("تهران"),
        then: yup.string().length(8, "اگر در آدرس کلمه ی تهران باشد تلفن باید 8 رقمی باشد")
      }),
    props: {
      name: "phoneNum",
      label: "شماره تلفن ثابت",
      placeholder: "شماره تلفن ثابت",
      type: "number",
      required: true,
      preserveErrorBox: true
    }
  }

```

### ولیدیشن های آپشنال:
اگر بخواهیک یک فیلد ولیدیشن بگیرد مثلا حتما موبایل 11 رقم باشد ولی در عین حال اگر موبایل خالی بود کلا ولیدیشن چک نشود میتوانید از متد زیر استفاده کنیم:

```js
.optional()
```

(لازم به ذکر است این متد توسط ما override شده است و متد دیفالت yupنیست زیرا آن متد فقط undefined را چک میکرد ولی در فرم ما اگر یک فیلد را پر و سپس خالی کنیم همچنان به آن ارور میدهد)

#### یک نمونه:

```js
yup.string().length(8, "تلفن باید 8 رقمی باشد").optional()

```

### ولیدیشن های خاص:
از آنجایی که برای ولیدیشن از yup استفاده شده است، یکسری ولیدیشن های خاص به متد های این کتابخانه افزوده شده است و قابل استفاده است که لیست آن به این شرح است:

این متد ها با استفاده از الگوریتم های خاص اعتبار سنجی میکنند. به طور مثال کد ملی یا شماره کارت یا شماره شبا و .. الگوریتم های ریاضی دارند.

- **iranNationalId**: صحت کد ملی را بررسی میکند
- **iranMobile**: صحت شماره موبایل را بررسی میکند
- **iranBankCard**: صحت کارت بانک را بررسی میکند
- **iranShebaNumber**: صحت شماره شبا را بررسی میکند
- **iranPostalCode**: صحت کد پستی را بررسی میکند
- **ipAddress**: صحت آدرس آی پی را بررسی میکند
- **ucFirst**: حرف اول متن را به حرف بزرگ تبدیل میکند

#### یک نمونه:

```js
yup.string().iranNationalId("صحت کد ملی مورد تایید نیست").required("کد ملی الزامی میباشد")

```


### یک نمونه از ولیدیشن یک فیلد بر اساس فیلد خودش :
ولیدیشن یک فیلد میتواند به فیلد دیگری وابسته باشد. ولی همچنین میتواند به خودش نیز وابسته باشد. البته این امر باعث میشود ارور cyclic dependency بدهد که این موضوع در فرم بیلدر هندل شده است. کاربرد این نوع وابستگی مثلا میتواند به این شکل باشد که یک فیلد زمانی یک ولیدیشن بگیرد که خودش یک شرطی را داشته باشد.


در این مثال تلفن اگر در تلفن کد 021 وجود داشت آنگاه تلفن باید 8 رقمی باشد. در غیر اینصورت اگر 021 وجود نداشت کلا چنین ولیدیشنی چک نخواهد شد.

همانطور که مشاهده میکنید workingPhone در قسمت when مجدد دارد خودش یعنی workingPhone را چک میکند.


```js
    {
      fieldType: "Input",
      width: "1/2",
      rule: yup.string().when("workingPhone", {
        is: val => val?.includes("021"),
        then: yup.string().length(8, "تلفن باید 8 رقمی باشد")
      }),
      props: {
        name: "workingPhone",
        label: "شماره تلفن کاری",
        placeholder: "شماره تلفن کاری",
        type: "number",
        required: true,
        preserveErrorBox: true
      }
    },

```


### یک نمونه از دیزیبل کردن یک فیلد بر اساس فیلدی دیگر:
اگر بخواهیم مثلا فیلد شماره شبا تا زمانی که کارت بانکی خالی است به حالت disable در بیاید و قفل باشد، میتوانیم آن را در props تنظیم کنیم. به این منظور کافیست props را از حالت object به حالت فانکشن در بیاوریم و همانطور که در بالاتر توضیح داده شده، در این صورت به مقادیر فرم درسترسی خواهیم داشت. در نتیجه میتوانیم مقدار فیلد دیگری که در فرم وجود دارد را چک کرده و تصمیم بگیریم. به عنوان مثال در مثال زیر شماره شبا اگر bankcard خالی بود به حالت disable در خواهد آمد:

```js
  {
    fieldType: "InputSheba",
    props: formProps => ({
      name: "shebaNum",
      label: "شماره شبا",
      preserveErrorBox: true,
      disabled: !formProps?.watch("bankcard") ? true : false
    }),
    width: "1/2"
  }
```

### فیلد گروپ ( فیلد در فیلد):

گاهی ممکن است در درون یک فیلد بخواهیم مجدد فیلد قرار دهیم (البته میبایست توسط wrapper هندل گردد ) در این حالت فرم بیلدر نیز چنین امکانی را دارد. کافیست در schema یک پراپرتی به نام **fileds** قرار دهیم که فرمت آن آرایه و عینا مشابه همان schema که به خود فرم میدادیم است.

شایان ذکر است که در این حالت هم همچنان validations و ... کار میکند و باقی موارد همانند حالت عادی کار میکند.


#### نمونه استفاده از این قابلیت که در FiledGroup هندل شده و قابل استفاده است:

```js
 {
      fieldType: "FieldGroup",
      props: {
        name: "hoviyati",
        groupLabel: "اطلاعات هویتی",
        preserveErrorBox: true
      },
      fields: [
        {
          fieldType: "Input",
          rule: yup.string().required("موبایل الزامی میباشد").length(11, "موبایل باید 11 رقم باشد"),
          props: {
            name: "mobileNum",
            label: "شماره موبایل",
            placeholder: "شماره موبایل",
            type: "number",
            required: true,
            preserveErrorBox: true
          }
        },
   }
```

